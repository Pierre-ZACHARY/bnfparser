<module> := <declaration> <module> | ε;

<declaration> := <struct-declaration> | <enum-declaration> | <method-declaration> | <process-declaration>;

<struct-declaration> := struct <lid> <zero-or-one-struct-type-list> { <zero-or-more-lid-type-list> };
<zero-or-one-struct-type-list> := \u003c <zero-or-more-uid-list> \u003e | ε;
<zero-or-more-lid-type-list> := <lid> : <type> <zero-or-more-lid-type-list> | ε;
<zero-or-more-uid-list> := <uid> <zero-or-more-uid-list> | ε;

<enum-declaration> := enum <lid> <zero-or-one-struct-type-list> { <zero-or-more-cons-def-list> };
<zero-or-more-cons-def-list> := <id> | <id> ( <zero-or-more-type-list> ) | ε;
<zero-or-more-type-list> := <type> <zero-or-more-type-list> | ε;

<type> := bool | int | float | char | string | <id> \u003c <type> \u003e | <uid>;

<method-declaration> := method <lid> ( <zero-or-more-lid-type-list> ) { <zero-or-one-statement> };
<process-declaration> := process <lid> ( <zero-or-more-lid-type-list> ) { <zero-or-one-statement> };
<zero-or-one-statement> := <statement> | ε;


<zero-or-one-mut> := mut | ε;

<statement> := <statement-not-recursive> \u003b <statement>
| <statement-not-recursive> \u007c\u007c <statement>
| var <zero-or-one-mut> <lid> : <type> <zero-or-one-equal-expression>
| signal <lid>
| <expression> = <expression>
| <block-statement> <statement>
| if ( <expression> ) <statement>
| if ( <expression> ) <statement> else <statement>
| while ( <expression> ) <statement>
| case ( <expression> ) <one-or-more-case>
| <lid> ( <zero-or-more-expression> )
| return <zero-or-one-expression>
| emit <id>
| when <id> <statement>
| watch <id> <statement>
| { <zero-or-one-statement> };

<statement-not-recursive> := var <zero-or-one-mut> <lid> : <type> <zero-or-one-equal-expression>
                             | signal <lid>
                             | <expression> = <expression>
                             | <block-statement> <statement>
                             | if ( <expression> ) <statement>
                             | if ( <expression> ) <statement> else <statement>
                             | while ( <expression> ) <statement>
                             | case ( <expression> ) <one-or-more-case>
                             | <lid> ( <zero-or-more-expression> )
                             | return <zero-or-one-expression>
                             | emit <id>
                             | when <id> <statement>
                             | watch <id> <statement>
                             | { <zero-or-one-statement> };

<zero-or-one-equal-expression> := = <expression> | ε;
<zero-or-one-expression> := <expression> | ε;
<zero-or-more-expression> := <expression> <zero-or-more-expression> | ε;
<zero-or-more-expression-not-recursive> := <expression-not-recursive > <zero-or-more-expression-not-recursive> | ε;

<block-statement> := { <zero-or-one-statement> }
| if ( <expression> ) { <zero-or-one-statement> }
| if ( <expression> ) <statement> else { <zero-or-one-statement> }
| while ( <expression> ) { <zero-or-one-statement> }
| when ( <id> ) { <zero-or-one-statement> }
| watch ( <id> ) { <zero-or-one-statement> };

<pattern> := <lid> | <uid> | <uid> ( <zero-or-more-pattern> );
<zero-or-more-pattern> := <pattern> <zero-ore-more-pattern> | ε;

<case> := <pattern> : <statement>;

<bool> := true | false;
<int> := ^[0-9]+;
<float> := ^[0-9]+[.][0-9]+;
<char> := ^['][a-zA-Z]['];
<string> := ^["][a-zA-Z0-9_-]*["];

<expression> := <expression-not-recursive> <binop> <expression>
| <expression-not-recursive> [ <expression> ]
| <expression-not-recursive> . <lid>
| ( <expression> )
| <unop> <expression>
| & mut <expression>
| & <expression>
| * <expression>
| [ <zero-or-more-expression> ]
| { <zero-or-more-field-expression> }
| <id> ( <zero-or-more-expression> )
| <id> ( <zero-or-more-expression> )
| <lid>
| <id>
| <char> | <bool> | <int> | <float> | <string>;

<expression-not-recursive> := <lid>
                              | <bool> | <int> | <float> | <char> | <string>
                              | ( <expression-not-recursive> )
                              | <unop> <expression-not-recursive>
                              | & mut <expression-not-recursive>
                              | & <expression-not-recursive>
                              | * <expression-not-recursive>
                              | [ <zero-or-more-expression-not-recursive> ]
                              | { <zero-or-more-field-expression-not-recursive> }
                              | <id>
                              | <id> ( <zero-or-more-expression> )
                              | <id> ( <zero-or-more-expression> ) ;

<field-expression> := <id> : <expression>;
<field-expression-not-recursive>  := <id> : <expression-not-recursive>;

<zero-or-more-field-expression> := <field-expression> <zero-or-more-field-expression> | ε;
<zero-or-more-field-expression-not-recursive> := <field-expression-not-recursive> <zero-or-more-field-expression-not-recursive> | ε;

<unop> := - | !;

<binop> := + | - | * | / | % | \u003c | \u003e | \u003c = | \u003e = | = = | ! = | and | or;

<uid> := <variablename>;
<lid> := <variablename>;
<id> := <variablename>;

# Regex : peut commencer par n'importe quelle lettre minuscule ou majuscule + _, et peut contenir autant de lettres ou de chiffre que nécessaire
<variablename> := ^[a-zA-Z_][a-zA-Z_0-9]*;